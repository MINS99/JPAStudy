+ 이 장에서 다루는 내용
  + 객체지향 쿼리 소개
  + JPQL
  + Criteria
  + QueryDSL
  + 네이티브 SQL
  + 객체지향 쿼리 심화
  
+ JPA는 복잡한 검색 조건을 사용해서 엔티티 객체를 조회할 수 있는 다양한 쿼리 기술을 지원
+ JPQL은 가장 중요한 객체지향 쿼리 언어. Criteria, QueryDSL은 JPQL을 편리하게 사용하도록 도와주는 기술


## 10.1 객체지향 쿼리 소개
+ em.find() 메소드를 사용하면 식별자로 엔티티 하나를 조회할 수 있고 조회한 엔티티에 객체 그래프 탐색을 사용하면 연관된 엔티티들을 찾을 수 있다
+ 단순한 검색 방법(em.find(), a.getB())만으로 애플리케이션을 개발하기는 어렵다
+ JPQL은 엔티티 객체를 대상으로 하는 객체지향 쿼리이다
  + 테이블이 아닌 객체를 대상으로 검색
  + SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않음
+ JPA는 JPQL을 분석한 다음 적절한 SQL을 만들어 데이터베이스를 조회한 후 엔티티 객체를 생성해서 반환한다
+ JPA가 공식 지원하는 검색 기능
  + JPQL(Java Persistence Query Language)
  + Criteria 쿼리 : JPQL을 편하게 작성하도록 도와주는 API, 빌더 클래스 모음
  + 네이티브 SQL : JPA에서 JPQL 대신 직접 SQL을 사용할 수 있다
+ 그 외 기능
  + QueryDSL : Criteria 처럼 JPQL을 편하게 작성하도록 도와주는 빌더 클래스 모음. 비표준 오픈소스 프레임워크
  + JDBC, Mybatis 등의 매퍼 프레임워크 : 필요하면 JDBC를 직접 사용할 수 있다

### **10.1.1 JPQL 소개**
+ JPQL은 엔티티 객체를 조회하는 객체지향 쿼리이다
+ 문법은 SQL과 비슷하고 ANSI 표준 SQL이 제공하는 기능을 유사하게 지원
+ SQL을 추상화해서 특정 데이터베이스에 의존하지 않음
+ 엔티티 직접 조회, 묵시적 조인, 다형성 지원으로 SQL 보다 코드가 간결하다
``` java
    // java 코드
    String jpql = "select m from Member as m where m.username = 'kim'";
    List<Member> resultList = em.createQuery(jpql, Member.class).getResultList();
    
    // 실행한 JPQL
    select m from Member as m where m.username = 'kim'
    
    // 실제 실행된 SQL
    select member.id as id, member.age as age, member.team_id as team, member.name as name
    from Member member where member.name='kim'
```

### **10.1.2 Criteria 쿼리 소개**
+ Criteria의 장점은 문자가 아닌 query.select(m).where(...) 처럼 프로그래밍 코드로 JPQL을 작성할 수 있다는 점
+ 문자가 아닌 코드로 JPQL을 작성하므로 컴파일 시점에 오류를 발견할 수 있다
+ IDE를 사용하면 코드 자동완성을 지원한다
+ 동적 쿼리를 작성하기 편하다
``` java
    // Criteria 사용 준비
    CriteriaBuilder cb = em.getCriteriaBuilder();
    CriteriaQuery<Member> query = cb.createQuery(Member.class);
    
    // 루트 클래스(조회를 시작할 클래스)
    Root<Member> m = query.from(Member.class);
    
    // 쿼리 생성
    CriteriaQuery<Member> cq = query.select(m).where(cb.equal(m.get("usermane"), "kim"));
    List<Member> resultList = em.createQuery(cq).getResultList(); 
```

+ m.get("username")을 보면 필드 명을 문자로 작성했다. 코드로 작성하고 싶으면 메타 모델을 사용하면 된다.

### **10.1.4 네이티브 SQL 소개**
+ SQL을 직접 사용할 수 있는 기능을 JPA가 제공
+ 특정 데이터베이스에 의존하는 기능을 사용해야 할 때(오라클 connect by 등) 사용
+ SQL은 지원하지만 JPQL이 지원하지 않는 기능 사용시 네이티브 SQL 사용
+ 특정 데이터베이스에 의존하는 SQL을 작성해야 함. 데이터베이스 변경시 네이티브 SQL도 수정해야 함
``` java
    // 네이티브 SQL
    String sql = "SELECT ID, AGE, TEAM_ID, NAME FROM MEMBER WHERE NAME = 'kim'";
    List<Member> resultList = em.createNativeQuery(sql, Member.class).getResultList();
```

### **10.1.5 JDBC 직접 사용, 마이바티스 같은 SQL 매퍼 프레임워크 사용**
+ JDBC 커넥션에 직접 접근하고 싶으면 JPA 구현체가 제공하는 방법을 사용해야 한다
+ JPA EntityManager에서 하이버네이트 Session을 구한 후 doWork() 호출
``` java
    // 하이버네이트 JDBC 획득
    Session session = entityManager.unwrap(Session.class);
    session.doWork(new Work() {
        @Override
        public void execute(Connection connection) throws SQLExcetion {
            // work...
        }
    });
```

+ JDBC나 마이바티스를 JPA와 함께 사용하면 영속성 컨텍스트를 적절한 시점에 강제로 플러시해야 함
+ JPA 우회하는 SQL에 대해서는 JPA가 전혀 인식하지 못함. 영속성 컨텍스트와 데이터베이스를 불일치 상태로 만들어 데이터 무결성을 훼손할 수 있다
+ SQL 실행 직전 영속성 컨텍스트를 수동으로 플러시해서 동기화 하면 된다
+ 스프링 프레임워크를 사용하면 JPA와 마이바티스를 손쉽게 통합할 수 있다

## 10.2 JPQL
+ 엔티티를 쿼리하는 다양한 방법들 중 어떤 방법을 사용하든 JPQL에서 모든 것이 시작됨
+ JPQL의 특징
  + 객체지향 쿼리 언어이다. 엔티티 객체를 대상으로 쿼리한다
  + SQL을 추상화해서 특정 데이터베이스의 SQL에 의존하지 않는다
  + 결국 SQL로 변환된다
+ 예제로 사용할 도메인 모델
<img src="그림 10.1, 10.2">

### **10.2.1 기본 문법과 쿼리 API**
+ JPQL도 SELECT, UPDATE, DELETE 문을 사용할 수 있다. INSERT는 em.persist()를 사용한다

#### SELECT 문
``` java
  SELECT m FROM Member AS m where m.username = 'Hello'
```

+ 대소문자 구분
  + 엔티티와 속성은 대소문자를 구분하며, SELECT, FROM, AS 같은 JPQL 키워드는 대소문자를 구분하지 않는다
+ 엔티티 이름
  + JPQL에서 사용한 Member는 클래스명이 아니라 엔티티명이다. 엔티티명은 `@Entity(name = "XXX")`로 지정. 기본값인 클래스명을 엔티티명으로 사용하는 것을 추천.
+ 별칭은 필수
  + JPQL은 별칭을 필수로 사용해야 한다. 별칭 없이 작성시 오류가 발생한다

#### TypeQuery, Query
+ 작성한 JPQL을 실행하려면 쿼리 객체를 만들어야 함. 
+ 반환할 타입을 명확하게 지정할 수 있으면 TypeQuery, 반환 타입을 명확하게 지정할 수 없으면 Query 객체를 사용
+ Query 객체는 SELECT 절의 조회 대상이 예제처럼 둘 이상이면 Object[]를 반환하고 하나이면 Object를 반환한다.
``` java
  TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class);
  Query<Member> query2 = em.createQuery("SELECT m.username, m.age FROM Member m");

  List<Member> resultList = query.getResultList();
  List resultList2 = query.getResultList();

  for(Member member :  resultList) {
	System.out.println("member = " + member);
  }
  for(Object o : resultList2) {
	Object[] result = (Object[]) o;	// 결과가 둘 이상이면 Object[] 반환
	System.out.println("username = " + result[0]);
	System.out.println("age = " + result[1]);
  }
```

#### 결과 조회
+ query.getResultList() : 결과를 예제로 반환. 결과가 없으면 빈 컬렉션 반환
+ query.getSingleResult() : 결과가 정확히 하나일 때 사용. 결과가 없으면 NoResultException, 1개보다 많으면 NonUniqueResultException 예외 발생.

### **10.2.2 파라미터 바인딩**
+ JPQL은 위치 기준 파라미터, 이름 기준 파라미터 바인딩을 지원
+ 파라미터 바인딩이 아닌 직접 문자를 더해 만들어 넣으면 SQL 인젝션 공격을 당할 수 있으며, 성능 이슈도 있으므로 선택이 아닌 필수로 사용해야함

#### 이름 기준 파라미터
+ 파라미터를 이름으로 구분하는 방법. 앞에 :를 사용한다
``` java
  String usernameParam = "User1";

  TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m where m.username = :username", Member.class);
  query.setParameter("username", usernameParam);

  List<Member> resultList = query.getResultList();
```

#### 위치 기준 파라미터
+ ? 다음에 위치 값을 주면 된다. 위치 값은 1부터 시작

``` java
  String usernameParam = "User1";

  List<Member> members = em.createQuery("SELECT m FROM Member m where m.username = ?1", Member.class)
                            .setParameter(1, usernameParam)
                            .getResultList();
```

+ 위치 기준 파라미터 방식보다는 이름 기준 파라미터 바인딩 방식을 사용하는 것이 더 명확

### **10.2.3 프로젝션**
+ SELECT 절에 조회할 대상을 지정하는 것을 프로젝션이라 함
+ [SELECT {프로젝션 대상} FROM]으로 대상 선택
+ 프로젝션 대상은 엔티티, 임베디드 타입, 스칼라(숫자, 문자 등 기본 데이터) 타입

#### 엔티티 프로젝션
``` java
  SELECT m FROM Member m    // 회원
  SELECT m.team FROM Member m   // 팀
```
+ 엔티티를 프로젝션 대상으로 사용하여 원하는 객체를 바로 조회한다
+ 컬럼을 하나하나 나열해서 조회해야 하는 SQL과는 차이가 있다
+ 조회한 엔티티는 영속성 컨텍스트에서 관리된다

#### 임베디드 타입 프로젝션
``` java
  String query = "SELECT o.address FROM Order o";
  List<Address> addresses = em.createQuery(query, Address.class)
                                .getResultList();
```
+ JPQL에서 임베디드 타입은 엔티티와 거의 비슷하게 사용된다
+ 임베디드 타입은 조회의 시작점이 될 수 없다(Address가 아닌 Order로 조회해야 함)
+ 임베디드 타입은 값 타입이므로 영속성 컨텍스트에서 관리되지 않는다

#### 스칼라 타입 프로젝션
``` java
  List<String> username = em.createQuery("SELECT DISTINCT username FROM Member m", String.class)
                            .getResultList();

  Double orderAmountAvg = em.createQuery("SELECT AVG(o.orderAmount) FROM Order o", Double.class)
                            .getSingleResult();
```
+ 스칼라 타입 : 숫자, 문자, 날짜와 같은 기본 데이터 타입들
+ 통계 쿼리도 주로 스칼라 타입으로 조회

#### 여러 값 조회
``` java
  List<Object[]> resultList = em.createQuery("SELECT o.member, o.product, o.orderAmount FROM Order o");
                                .getResultList();
  
  for(Object[] row : resultList) {
      Member member = (Member) row[0];  // 엔티티
      Product product = (Product) row[1];   // 엔티티
      int orderAmount = (Integer) row[2];   // 스칼라
  }
```
+ 엔티티를 대상으로 하지 않고 꼭 필요한 데이터들만 선택해서 조회해야 할 때도 있다
+ 프로젝션에 여러 값을 선택하면 Query를 사용해야 한다
+ 제네릭의 Object[] 사용시 간결하게 개발 가능
+ 조회한 엔티티는 영속성 컨텍스트에서 관리된다

#### NEW 명령어
``` java
  TypedQuery<UserDTO> query = em.createQuery("SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m", UserDAO.class);
  
  List<UserDTO> resultList = query.getResultList();
```
+ 실제 애플리케이션 개발 시 Object[]를 직접 사용하지 않고 UserDTO 처럼 의미 있는 객체로 변환해서 사용
+ SELECT 다음 new 명령어를 사용하여 클래스 생성자에 JPQL 조회 결과를 넘겨주고, TypeQuery를 사용
+ new 명령어 사용시 1) 패키지 명을 포함한 전체 클래스 명을 입력해야 하고 2) 순서와 타입이 일치하는 생성자가 필요하다

### **10.2.4 페이징 API**
``` java
  TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m ORDER BY m.username DESC", Member.class);
                                .setFirstResult(10);
                                .setMaxResults(20);
                                .getResultList();
```
+ 페이징 처리용 SQL을 작성하는 일은 지루하고 반복적이며, 데이터베이스마다 페이징을 처리하는 SQL문법이 다르다는 문제가 있다
+ JPA는 페이징을 두 API로 추상화 했다
  + setFirstResult(int startPosition) : 조회 시작 위치(0부터 시작)
  + setMaxResults(int maxResult) : 조회할 데이터 수
+ JPQL이 데이터베이스 방언에 따라 다르게 처리를 하여 SQL을 변환한다
+ 페이징 SQL을 더 최적화하고 싶다면 네이티브 SQL을 직접 사용해야 함

### **10.2.5 집합과 정렬**
+ 집합은 집합함수와 함께 통계 정보를 구할 때 사용

#### 집합 함수
| 함수 | 설명 |
| --- | --- |
| COUNT | 결과 수를 구한다. 반환 타입: Long | 
| MAX, MIN | 최대, 최소 값을 구한다. 문자, 숫자, 날짜 등에 사용한다. |
| AVG | 평균값을 구한다. 숫자타입만 사용할 수 있다. 반환 타입: Double |
| SUM | 합을 구한다. 숫자타입만 사용할 수 있다. 반환 타입: 정수합 Long, 소수합: Double, <br> Biginteger합: Biginteger, BigDecimal합: BigDecimal |

#### 집합 함수 사용 시 참고사항
+ NULL 값은 무시하므로 통계에 잡히지 않는다(DISTINCT가 정의되어 있어도 무시)
+ 값이 없는데 SUM, AVG, MAX, MIN 함수를 사용하면 NULL 값이 된다. COUNT는 0이 된다
+ DISTINCT를 집합 함수 안에 사용해서 중복된 값을 제거하고 나서 집합을 구할 수 있다
`select COUNT(DISTINCT m.age) from Member m`
+ DISTINCT를 COUNT에서 사용할 때 임베디드 타입은 지원하지 않는다